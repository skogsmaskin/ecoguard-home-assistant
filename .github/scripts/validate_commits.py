#!/usr/bin/env python3
"""
Validate that commit messages follow the Conventional Commits specification.

Conventional Commits format:
<type>[optional scope]: <description>

[optional body]

[optional footer(s)]

Types: feat, fix, docs, style, refactor, perf, test, build, ci, chore, revert
"""

import re
import sys
from subprocess import check_output
from typing import Optional

# Allowed commit types
ALLOWED_TYPES = [
    "feat",
    "fix",
    "docs",
    "style",
    "refactor",
    "perf",
    "test",
    "build",
    "ci",
    "chore",
    "revert",
]

# Conventional commit pattern
# Format: <type>[optional scope]: <description>
CONVENTIONAL_COMMIT_PATTERN = re.compile(
    r"^(?P<type>" + "|".join(ALLOWED_TYPES) + r")"
    r"(?P<scope>\([^)]+\))?"
    r"(?P<breaking>!)?"
    r":\s+"
    r"(?P<description>.+)"
    r"$"
)

# Revert commit pattern (revert commits should still follow conventional format)
# But we allow the standard "Revert" format as it's part of conventional commits
REVERT_COMMIT_PATTERN = re.compile(r"^Revert \".+\"$")


def get_commit_messages(base_ref: Optional[str] = "HEAD~1") -> list[str]:
    """Get commit messages between base_ref and HEAD, excluding auto-generated merge commits."""
    try:
        if base_ref is None:
            # Get all commits in HEAD (for first push to branch), excluding auto-generated merges
            commits = check_output(
                ["git", "log", "--no-merges", "--format=%s", "HEAD"],
                text=True,
            ).strip()
        else:
            # Get the range of commits, excluding auto-generated merge commits
            # Merge commits are auto-generated by Git/GitHub and can't follow conventional format
            commits = check_output(
                ["git", "log", "--no-merges", "--format=%s", f"{base_ref}..HEAD"],
                text=True,
            ).strip()
    except Exception as e:
        print(f"Error getting commits: {e}")
        # If comparison fails, try to get just the last commit (if not a merge)
        try:
            commits = check_output(
                ["git", "log", "-1", "--no-merges", "--format=%s", "HEAD"],
                text=True,
            ).strip()
        except Exception as e2:
            print(f"Error getting last commit: {e2}")
            return []

    if not commits:
        return []

    return [msg for msg in commits.split("\n") if msg.strip()]


def validate_commit_message(message: str) -> tuple[bool, str]:
    """Validate a single commit message - all commits must follow conventional format."""
    message = message.strip()

    # Allow revert commits (they follow a specific conventional format)
    if REVERT_COMMIT_PATTERN.match(message):
        return True, ""

    # Check conventional commit format
    match = CONVENTIONAL_COMMIT_PATTERN.match(message)
    if not match:
        return (
            False,
            f"Commit message does not follow Conventional Commits format.\n"
            f"Expected: <type>[optional scope]: <description>\n"
            f"Got: {message}\n"
            f"Allowed types: {', '.join(ALLOWED_TYPES)}",
        )

    # Check description length (recommended: 50 chars, max 72)
    description = match.group("description")
    if len(description) > 72:
        return (
            False,
            f"Commit description is too long ({len(description)} chars). "
            f"Keep it under 72 characters.\n"
            f"Description: {description}",
        )

    return True, ""


def main():
    """Main validation function."""
    import os

    # Determine the base reference based on event type
    github_event_name = os.environ.get("GITHUB_EVENT_NAME", "")
    github_base_ref = os.environ.get("GITHUB_BASE_REF")
    github_before = os.environ.get("GITHUB_BEFORE")  # SHA before push
    github_after = os.environ.get("GITHUB_AFTER")    # SHA after push

    if github_event_name == "pull_request" and github_base_ref:
        # PR context - compare with base branch (only new commits in PR)
        # Use origin/base_ref to ensure we're comparing against the remote base branch
        base_ref = f"origin/{github_base_ref}"
        # Verify the base ref exists
        try:
            check_output(["git", "show-ref", "--verify", f"refs/remotes/{base_ref}"], text=True)
            print(f"Comparing against base branch: {base_ref}")
        except Exception:
            # Try without origin prefix
            try:
                check_output(["git", "show-ref", "--verify", f"refs/heads/{github_base_ref}"], text=True)
                base_ref = github_base_ref
                print(f"Comparing against base branch: {base_ref}")
            except Exception:
                # Fallback to HEAD~1 if base branch not found
                print(f"Warning: Base branch '{github_base_ref}' not found, using HEAD~1")
                base_ref = "HEAD~1"
    elif github_event_name == "push":
        if github_before and github_before != "0000000000000000000000000000000000000000":
            # Push event - compare with the commit before the push (only new commits)
            base_ref = github_before
            print(f"Validating commits pushed after {github_before[:7]}...")
        else:
            # First push to branch or deleted branch - validate all commits in HEAD
            # This is a new branch, so validate all commits
            print("First push to branch detected, validating all commits in HEAD...")
            base_ref = None  # Will validate all commits
    else:
        # Fallback: validate only the last commit
        print("Warning: Could not determine base reference, validating only the last commit")
        base_ref = "HEAD~1"

    commit_messages = get_commit_messages(base_ref)

    if not commit_messages:
        print("No commits to validate.")
        return 0

    print(f"Validating {len(commit_messages)} commit(s)...\n")

    errors = []
    for i, message in enumerate(commit_messages, 1):
        print(f"Commit {i}: {message[:50]}...")
        is_valid, error_msg = validate_commit_message(message)
        if not is_valid:
            errors.append(f"Commit {i}: {error_msg}")

    if errors:
        print("\n❌ Validation failed:\n")
        for error in errors:
            print(error)
            print()
        print(
            "Please ensure your commit messages follow the Conventional Commits format:\n"
            "<type>[optional scope]: <description>\n\n"
            "Examples:\n"
            "  feat: add new sensor for water consumption\n"
            "  fix(api): handle authentication errors\n"
            "  docs: update installation instructions\n"
            "  chore: update dependencies\n"
        )
        return 1

    print("\n✅ All commit messages are valid!")
    return 0


if __name__ == "__main__":
    sys.exit(main())
